---
title: k8s指令详解
date: 2024-06-26 10:32:32
permalink: /note/normal/k8sCmd/
categories:
  - 更多
  - 技术文档
tags:
  - docker
author: 
  name: Orochi
  link: https://github.com/765741668

---

陈述式资源管理方法：
1.kubernetes 集群管理集群资源的唯一入口是通过相应的方法调用 apiserver 的接口
2.kubectl 是官方的CLI命令行工具，用于与 apiserver 进行通信，将用户在命令行输入的命令，组织并转化为 apiserver 能识别的信息，进而实现管理 k8s 各种资源的一种有效途径
3.kubectl 的命令大全
kubectl --help
k8s中文文档：http://docs.kubernetes.org.cn/683.html
4.对资源的增、删、查操作比较方便，但对改的操作就不容易了


//查看版本信息
kubectl version

//查看资源对象简写
kubectl api-resources

//查看集群信息 
kubectl cluster-info

//配置kubectl自动补全
source <(kubectl completion bash)

//node节点查看日志
journalctl -u kubelet -f

---------- 基本信息查看 ----------
kubectl get <resource> [-o wide|json|yaml] [-n namespace]
获取资源的相关信息，-n 指定命令空间，-o 指定输出格式
resource可以是具体资源名称，如pod nginx-xxx；也可以是资源类型，如pod；或者all(仅展示几种核心资源，并不完整)
--all-namespaces 或 -A ：表示显示所有命令空间，
--show-labels ：显示所有标签
-l app ：仅显示标签为app的资源
-l app=nginx ：仅显示包含app标签，且值为nginx的资源

//查看 master 节点状态
kubectl get componentstatuses
或者
kubectl get cs

//查看命令空间
kubectl get namespace
或者
kubectl get ns
//命令空间的作用：用于允许不同 命令空间 的 相同类型 的资源 重名的

//查看default命名空间的所有资源
kubectl get all [-n default]

//创建命名空间app
kubectl create ns app
kubectl get ns

//删除命名空间app
kubectl delete namespace app
kubectl get ns            

//在命名空间kube-public 创建副本控制器（deployment）来启动Pod（nginx-wl）
kubectl create deployment nginx-wl --image=nginx  -n kube-public 

//描述某个资源的详细信息
kubectl describe deployment nginx-wl -n kube-public
或者
kubectl describe pod nginx-wl-d47f99cb6-hv6gz -n kube-public

//查看命名空间kube-public 中的pod 信息
kubectl get pods -n kube-public
NAME                       READY   STATUS    RESTARTS   AGE
nginx-wl-d47f99cb6-hv6gz   1/1     Running   0          24m

//kubectl exec可以跨主机登录容器，docker exec 只能在容器所在主机上登录
kubectl exec -it nginx-wl-d47f99cb6-hv6gz bash -n kube-public

//删除（重启）pod资源，由于存在deployment/rc之类的副本控制器，删除pod也会重新拉起来
kubectl delete pod nginx-wl-d47f99cb6-hv6gz -n kube-public

//若pod无法删除，总是处于terminate状态，则要强行删除pod
kubectl delete pod <pod-name> -n <namespace> --force --grace-period=0
#grace-period表示过渡存活期，默认30s，在删除pod之前允许POD慢慢终止其上的容器进程，从而优雅退出，0表示立即终止pod

//扩缩容
kubectl scale deployment nginx-wl --replicas=2 -n kube-public    # 扩容
kubectl scale deployment nginx-wl --replicas=1 -n kube-public    # 缩容

//删除副本控制器
kubectl delete deployment nginx-wl -n kube-public
kubectl delete deployment/nginx-wl -n kube-public

//项目的生命周期：创建-->发布-->更新-->回滚-->删除

1、创建    kubectl create命令
●创建并运行一个或多个容器镜像。
●创建一个deployment 或job 来管理容器。
kubectl create --help

//启动 nginx 实例，暴露容器端口 80，设置副本数 3
kubectl create deployment nginx --image=nginx:1.14 --port=80 --replicas=3

kubectl get pods
kubectl get all


2、发布    kubectl expose命令
●将资源暴露为新的 Service。
kubectl expose --help

//为deployment的nginx创建service，并通过Service的80端口转发至容器的80端口上，Service的名称为nginx-service，类型为NodePort
kubectl expose deployment nginx --port=80 --target-port=80 --name=nginx-service --type=NodePort

------------------------------------------------------------------------------------------
Kubernetes 之所以需要 Service，一方面是因为 Pod 的 IP 不是固定的（Pod可能会重建），另一方面则是因为一组 Pod 实例之间总会有负载均衡的需求。
Service 通过 Label Selector 实现的对一组的 Pod 的访问。
对于容器应用而言，Kubernetes 提供了基于 VIP（虚拟IP） 的网桥的方式访问 Service，再由 Service 重定向到相应的 Pod。

service 的 type 类型：
●ClusterIP：提供一个集群内部的虚拟IP以供Pod访问（service默认类型)

●NodePort：在每个Node上打开一个端口以供外部访问，Kubernetes将会在每个Node上打开一个端口并且每个Node的端口都是一样的，通过 NodeIp:NodePort 的方式Kubernetes集群外部的程序可以访问Service。
每个端口只能是一种服务，端口范围只能是 30000-32767。

●LoadBalancer：通过设置LoadBalancer映射到云服务商提供的LoadBalancer地址。这种用法仅用于在公有云服务提供商的云平台上设置Service的场景。通过外部的负载均衡器来访问，通常在云平台部署LoadBalancer还需要额外的费用。
在service提交后，Kubernetes就会调用CloudProvider在公有云上为你创建一个负载均衡服务，并且把被代理的Pod的IP地址配置给负载均衡服务做后端。

●externalName：将service名称映射到一个DNS域名上，相当于DNS服务的CNAME记录，用于让Pod去访问集群外部的资源，它本身没有绑定任何的资源。 tgc.benet.com   www.benet.com 


headless clusterIP  无头模式   名称


扩展
●port
port 是 k8s 集群内部访问service的端口，即通过 clusterIP: port 可以从 Pod 所在的 Node 上访问到 service

●nodePort
nodePort 是外部访问 k8s 集群中 service 的端口，通过 nodeIP: nodePort 可以从外部访问到某个 service。

●targetPort
targetPort 是 Pod 的端口，从 port 或 nodePort 来的流量经过 kube-proxy 反向代理负载均衡转发到后端 Pod 的 targetPort 上，最后进入容器。

●containerPort
containerPort 是 Pod 内部容器的端口，targetPort 映射到 containerPort。

------------------------------------------------------------------------------------------

//查看pod网络状态详细信息和 Service暴露的端口
kubectl get pods,svc -o wide
NAME                        READY   STATUS    RESTARTS   AGE   IP            NODE            NOMINATED NODE
pod/nginx-cdb6b5b95-fjm2x   1/1     Running   0          44s   172.17.26.3   192.168.80.11   <none>
pod/nginx-cdb6b5b95-g28wz   1/1     Running   0          44s   172.17.36.3   192.168.80.12   <none>
pod/nginx-cdb6b5b95-x4m24   1/1     Running   0          44s   172.17.36.2   192.168.80.12   <none>

NAME                    TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE   SELECTOR
service/kubernetes      ClusterIP   10.0.0.1     <none>        443/TCP        14d   <none>
service/nginx-service   NodePort    10.0.0.189   <none>        80:44847/TCP   18s   run=nginx

//查看关联后端的节点
kubectl get endpoints

//查看 service 的描述信息
kubectl describe svc nginx

//在 node01 节点上操作，查看负载均衡端口
yum install ipvsadm -y
ipvsadm -Ln
//外部访问的IP和端口
TCP  192.168.80.11:44847 rr
  -> 172.17.26.3:80               Masq    1      0          0         
  -> 172.17.36.2:80               Masq    1      0          0         
  -> 172.17.36.3:80               Masq    1      0          0     
//pod集群组内部访问的IP和端口
TCP  10.0.0.189:80 rr
  -> 172.17.26.3:80               Masq    1      0          0         
  -> 172.17.36.2:80               Masq    1      0          0         
  -> 172.17.36.3:80               Masq    1      0          0         

//在 node02 节点上操作，同样方式查看负载均衡端口
yum install ipvsadm -y
ipvsadm -Ln
TCP  192.168.80.12:44847 rr
  -> 172.17.26.3:80               Masq    1      0          0         
  -> 172.17.36.2:80               Masq    1      0          0         
  -> 172.17.36.3:80               Masq    1      0          0         

TCP  10.0.0.189:80 rr
  -> 172.17.26.3:80               Masq    1      0          0         
  -> 172.17.36.2:80               Masq    1      0          0         
  -> 172.17.36.3:80               Masq    1      0          0         

curl 10.0.0.189
curl 192.168.80.11:44847
//在master01操作 查看访问日志
kubectl logs nginx-cdb6b5b95-fjm2x
kubectl logs nginx-cdb6b5b95-g28wz
kubectl logs nginx-cdb6b5b95-x4m24


3、更新    kubectl set
●更改现有应用资源一些信息。
kubectl set --help

//获取修改模板
kubectl set image --help
Examples:
  # Set a deployment's nginx container image to 'nginx:1.9.1', and its busybox container image to 'busybox'.
  kubectl set image deployment/nginx busybox=busybox nginx=nginx:1.9.1

//查看当前 nginx 的版本号
curl -I http://192.168.80.11:44847
curl -I http://192.168.80.12:44847

//将nginx 版本更新为 1.15 版本
kubectl set image deployment/nginx nginx=nginx:1.15

//处于动态监听 pod 状态，由于使用的是滚动更新方式，所以会先生成一个新的pod，然后删除一个旧的pod，往后依次类推
kubectl get pods -w

//再看更新好后的 Pod 的 ip 会改变
kubectl get pods -o wide

//再看 nginx 的版本号
curl -I http://192.168.80.11:44847
curl -I http://192.168.80.12:44847


4、回滚    kubectl rollout 
●对资源进行回滚管理
kubectl rollout --help

//查看历史版本
kubectl rollout history deployment/nginx 

//执行回滚到上一个版本
kubectl rollout undo deployment/nginx

//执行回滚到指定版本
kubectl rollout undo deployment/nginx --to-revision=1

//检查回滚状态
kubectl rollout status deployment/nginx


5、删除    kubectl delete
//删除副本控制器
kubectl delete deployment/nginx

//删除service
kubectl delete svc/nginx-service

kubectl get all


//金丝雀发布（Canary Release）
Deployment控制器支持自定义控制更新过程中的滚动节奏，如“暂停(pause)”或“继续(resume)”更新操作。比如等待第一批新的Pod资源创建完成后立即暂停更新过程，此时，仅存在一部分新版本的应用，主体部分还是旧的版本。然后，再筛选一小部分的用户请求路由到新版本的Pod应用，继续观察能否稳定地按期望的方式运行。确定没问题之后再继续完成余下的Pod资源滚动更新，否则立即回滚更新操作。这就是所谓的金丝雀发布。
（1）更新deployment的版本，并配置暂停deployment
kubectl set image deployment/nginx nginx=nginx:1.14 && kubectl rollout pause deployment/nginx

kubectl rollout status deployment/nginx　　#观察更新状态

（2）监控更新的过程，可以看到已经新增了一个资源，但是并未按照预期的状态去删除一个旧的资源，就是因为使用了pause暂停命令
kubectl get pods -w 

curl [-I] 10.0.0.189
curl [-I] 192.168.80.11:44847

（3）确保更新的pod没问题了，继续更新
kubectl rollout resume deployment/nginx

（4）查看最后的更新情况
kubectl get pods -w 

curl [-I] 10.0.0.189
curl [-I] 192.168.80.11:44847

声明式管理方法：
1.适合于对资源的修改操作
2.声明式资源管理方法依赖于资源配置清单文件对资源进行管理
资源配置清单文件有两种格式：yaml（人性化，易读），json（易于api接口解析）
3.对资源的管理，是通过事先定义在统一资源配置清单内，再通过陈述式命令应用到k8s集群里
4.语法格式：kubectl create/apply/delete -f xxxx.yaml

//查看资源配置清单
kubectl get deployment nginx -o yaml

//解释资源配置清单
kubectl explain deployment.metadata

kubectl get service nginx -o yaml
kubectl explain service.metadata

//修改资源配置清单并应用
离线修改：
修改yaml文件，并用 kubectl apply -f xxxx.yaml 文件使之生效
注意：当apply不生效时，先使用delete清除资源，再apply创建资源

kubectl get service nginx -o yaml > nginx-svc.yaml
vim nginx-svc.yaml                #修改port: 8080
kubectl delete -f nginx-svc.yaml
kubectl apply -f nginx-svc.yaml
kubectl get svc

在线修改：
直接使用 kubectl edit service nginx 在线编辑资源配置清单并保存退出即时生效（如port: 888）
PS：此修改方式不会对yaml文件内容修改


//删除资源配置清单
陈述式删除：
kubectl delete service nginx

声明式删除：
kubectl delete -f nginx-svc.yaml